### 数据类型

#### 基本类型

> 1Byte=8bits

* byte：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0

* short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0

* int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0

* long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L

* float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0.0f

* double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0.0d

* char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空

* boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false

**区别: 基本数据类型和引用类型的区别主要在于基本数据类型是分配在栈上的，而引用类型是分配在堆上的（需要java中的栈、堆概念）**

### 方法

> 方法包括方法头和方法体，方法头又可以分为 修饰符、返回值类型、方法签名（方法名和参数列表）

#### 重载与重写

* 重载：是在同一个类中的两个或两个以上的方法，拥有相同的方法名，但是参数却不相同，方法体也不相同，最常见的重载的例子就是类的构造函数

* 重写：
    * 子类的方法覆盖父类的方法，要求返回值、方法名和参数都相同
    * 子类抛出的异常不能超过父类相应方法抛出的异常(子类异常不能超出父类异常)
    * 子类方法的的访问级别不能低于父类相应方法的访问级别(子类访问级别不能低于父类访问级别)

### 递归

>程序调用自身的编程技巧称为递归; 递归方法是直接或间接调用自身的方法。递归必须定义初始状态即终止条件

#### 递归优点

* 代码简洁且易于理解
* 若可以分解成子问题且子问题与原始问题相似，则可以使用递归给出自然、直接、简单的解法

#### 递归缺点

* 时间和空间的消耗比较大
* 若子问题之间存在重叠，且**在不加记忆化的情况**下，会产生重复计算，导致时间复杂度过高
* 由于栈的空间有限，如果递归调用的次数太多，则可能导致调用栈溢出

### 面向对象

#### 初始化块顺序

1. 执行父类的静态初始化块
1. 执行子类的静态初始化块
1. 执行父类的非静态初始化块
1. 执行父类的构造器
1. 执行子类的非静态初始化块
1. 执行子类的构造器

#### 关键字

* static
    * 作用在方法上：属于类，不属于类的实例对象；可通过类名直接调用；方法中不能有实例的成员
    * 作用在变量上：属于类，可以用类型引用
    * 作用在类上：只能有static的成员
    * static是在编译时候被绑定，加载时就会被执行，按顺序执行static变量和代码块
    * static方法不能被覆盖

* final
    * 类被声明为final，不能再派生出新的子类，不能被继承；一个类不能既被声明为abstract，又被声明为final
    * 被声明为final的变量，必须在声明时给定初值，在以后的引用中只能读取不可修改
    * 被声明为final的方法，只能使用不能重载

* finally
    * 在异常处理时提供finally快来执行任何清除工作，无论是否异常都将执行
    * 当try/catch中return时，finally仍然会执行
    * finally 是在return后面的表达式运算后执行的，（此时还没有返回运算后的值，而是先把要返回的值保存起来，不管finally中代码怎样，返回值都不会变，仍是保存前的值）
    * finally中最好不要包含return，否则程序会提前退出
* this
    * this 用于引用隐藏变量
    * this 用于调用其他构造方法
    * this 不能在静态代码块中使用

* finalize
    * finalize()方法：在垃圾回收器将对象从内存中清除出去前，做必要的清理工作
    * 在Object类定义，每个类都继承它
    * 子类覆盖finalize()方法，整理系统资源或执行其他清理工作

* native
    * 可以和其他一些修饰符连用，但不能修饰abstract方法和interface方法
    * 一个native方法就是一个Java调用非Java代码的接口，实现由非Java语言比如用C或C++实现

* strictfp
    * 精确浮点，可应用于类、接口或方法

* transient
    * 变量修饰符(只能修饰字段)，在对象存储时，这些变量状态不会被持久化，对象序列化的保存在存储器上时，不希望有些字段数据被保存，为了保证安全性，可以把这些字段声明为transient

* volatile
    * volatile只能保证变量的可见性（被修改的值立即更新到主存），不能保证对volatile变量操作的原子性
    * 确保有序性，禁止进行指令重排序

#### String StringBuffer StringBuilder区别

> 执行速度快慢为：StringBuilder > StringBuffer > String 
>
> String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，是AbstractStringBuilder 的子类

* 线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的，使用synchronized 修饰

* String使用数组存储字符串的内容，数组使用关键词 final 修饰，因此数组内容不可变，使用 String 定义的字符串的值也是不可变的，故 在字符修改上区别，String=a + b, 会产生新的对象

* 初始化上的区别，String可以空赋值，后者不行

#### equals 和 == 区别

* 对于基本数据类型，== 比较的是他们的值；对于符合数据类型，== 比较的是他们的内存地址
* equals，是Objec类的方法，用于比较两个对象是否相等，即堆中的内容是否相同，默认Object类的equals方法是比较两个对象的地址，跟==的结果一样
* 注：两个相等的对象一定具有相同的散列码（故若在子类中重写了equals方法，必须在该子类中重写 hashCode方法），两个不同的对象也可能具有相同的散列码。

#### 抽象类和接口的区别

* 抽象类的变量没有限制，接口只包含常量，即接口的所有变量必须是 public static final
* 抽象类包含构造方法，子类通过构造方法链调用构造方法，接口不包含构造方法
* 抽象类的方法没有限制，接口的方法必须是 public abstract 的实例方法，注：
    * 从 Java 8 开始，接口方法可以由默认实现
    * 从 Java 9 开始，接口内允许定义私有方法

* 一个类只能继承一个父类，但是可以实现多个接口；一个接口可以继承多个接口

##### 常量和枚举区别

* 使用常量类时，往往通过equals去判断两者是否相等，使用枚举的话由于常量值地址唯一，可以用==直接对比，性能会有提高
* 常量类编译是直接把常量的值编译到类的二进制代码里，常量的值在升级中变化后，需要重新编译引用常量的类。枚举类编译时，没有把常量值编译到代码里，枚举的扩展性更高
* 枚举类编译后默认为final class，不允许继承可防止被子类修改。常量类可被继承修改、增加字段等，容易导致父类的不兼容

### 异常处理

#### 异常错误

* 语法错误
* 逻辑错误
* 运行错误

#### 常见的异常类型

* NullPointerException：空指针异常
* ArrayIndexOutOfBoundsException：数组下标越界异常
* ArithmeticException：算术运算异常
* NumberFormatException：数字格式异常
* IOException：输入输出异常
* ClassCastException: 类型转换异常
* ClassNotFoundException：类加载异常
* NoSuchMethodException：方法不存在异常
* FileNotFoundException：文件找不到异常
* NoSuchFiledException：属性不存在异常
* IllegalAccessException：没有访问权限
* InterruptedException：被终止异常
* IllegalArgumentException：方法参数错误