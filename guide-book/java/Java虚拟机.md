### Java虚拟机

> Java 虚拟机在执行 Java程序的过程中会把它管理的内存划分成若干个不同的数据区域。

#### 运行时数据区域

* 程序计数器
* 虚拟机栈
* 本地方法栈
* 虚拟机堆
* 方法区（运行时常量池） - JDK1.8将方法区彻底移除，取而代之的是元空间，元空间使用的是直接内存

#### 垃圾回收

##### 判断对象是否可回收

* 引用计数算法
* 根搜索算法

##### GC Roots包含的对象

1. 虚拟机栈中引用的对象
1. 本地方法栈中的JNI本地方法引用的对象
1. 方法区中的类静态属性引用的对象
1. 方法区中的常量引用的对象

#### CMS

> CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”实现，在标记清理过程中不会导致用户线程无法定位引用对象。

##### 步骤

1. 初始标记：独占CPU，Stop-the-world，仅标记GC Roots能直接关联的对象，速度比较快
1. 并发标记：可以和用户线程并发执行，通过GC Roots Tracing 标记所有可达对象
1. 重新标记：独占CPU，Stop-the-world，对并发标记阶段用户线程运行产生的垃圾对象进行标记修正，以及更新逃逸对象
1. 并发清理：可以和用户线程并发执行，清理在重复标记中被标记为可回收的对象

##### 优缺点

**优点**

1. 支持并发收集
1. 低停顿，因为CMS可以将耗时的两个stop-the-world操作保持与用户线程恰当的时机并发执行，并且能保证在短时间执行完成

**缺点**

1. CMS收集器对CPU资源非常敏感，若在CPU资源不足的情况下应用会有明显的卡顿
1. 无法处理浮动垃圾：在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，故只能在下次执行清理时才会被回收，且处理时若用户线程内存不足会出现'Concurrent Mode Failure'
1. CMS清理后会产生大量的内存碎片

##### 适用

> 有垃圾回收最短的停顿时间（低停顿）的要求；在老年代并不频繁GC的场景下，比较适用

#### G1

> G1收集器的内存结构完全区别于CMS，弱化了CMS原有的分代模型（分代可以是不连续的空间），将堆内存划分成一个个Region（1MB~32MB, 默认2048个分区）

##### 步骤

1. 初始标记：标记一下GC Roots能直接关联到的对象，伴随着一次普通的Young GC发生，并修改NTAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象
1. 根区间扫描：标记所有幸存者区间的对象引用，扫描 Survivor到老年代的引用，该阶段必须在下一次Young GC 发生前结束
1. 并发标记：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长
1. 最终标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录
1. 筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划

##### 适用

> G1 GC是基于Region的GC，适用于大内存机器。即使内存很大，Region扫描，性能还是很高的


##### ZGC 
** 即 Z Garbage Collector**，是一个可伸缩的、低延迟的垃圾收集器。

ZGC 主要为了满足如下目标进行设计：

- GC 停顿时间不超过 10ms
- 即能处理几百 MB 的小堆，也能处理几个 TB 的大堆
- 应用吞吐能力不会下降超过 15%（与 G1 回收算法相比）
- 方便在此基础上引入新的 GC 特性和利用 colored 针以及 Load barriers 优化奠定基础
- 当前只支持 Linux/x64 位平台

ZGC 目前 **处在实验阶段**，只支持 Linux/x64 平台。

与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。

在 ZGC 中出现 Stop The World 的情况会更少！

详情可以看：[《新一代垃圾回收器 ZGC 的探索与实践》](https://tech